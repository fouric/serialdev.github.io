
# Books

|Title(url) | language| Book | blog | Theory | Implementation | pseudocode | List | Free | End-to-end |
|----------:|:-------:|:----:|:----:|:------:|:--------------:|:----------:|:----:|:----:|-----------:|
|Title(url) | language| Book | blog | Theory | Implementation | pseudocode | List | Free | End-to-end |

## AI / Machine Learning / Theoretical / Mathematical Optimization

## Information theory and compression

## Game Engine & Game Development

## HFT & Finance

## Information Retrieval and DB Systems

## Theoretical CS

## Operating Systems

## Distributed systems


## Infosec & Hacking & Game sec


## Low-Level programming

## Software Engineering General



## Lisps & Scheme



## Quantum Computation

## Computer Architecture

## Python


## Scientific Python


## Computer algebra and symbolic computation

## Mathematics & Statistics

## Cryptography

## Viz

### Nice viz/Ux examples

## Windows & Linux dev

## Miscellaneous


## Biological-inspired systems

# Papers

## Theory

## Lisp Schemes

# Projects

## C || Cpp || Asm

## Lisp Scheme etc

## Rust
## DB




## Python
## Haskell

## Other
## Algos

# Blogs

## People Pages
























ww

``` Scheme

```








### Pubs

[Peter Deutsch](https://dblp.org/pers/hd/d/Deutsch:L=_Peter )


# Cheatsheets



# Miscellaneous










# Extras  Non  link
```
It also helps to familiarize yourself with classical pathological syntax issues for languages like ALGOL-68
(requires 'semantic actions' to parse correctly) and early versions of FORTRAN
(identifiers could have intermediate whitespace,
which meant that a typo could corrupt the meaning of the program)
and figure out how to do parse a language with an Offside Rule
(and not all offside rules are created equal; Haskell 98 is very complex). 
Then look at techniques like scannerless/lexerless parsing (SGLR, PEG, etc.), 
combinatorial parsing, etc. Understand what mathematical properties of a parser 
algorithm and a parser generator you should look for to ease your job. 
Understand why naive user of a parser generator tends to result in slower 
lexing/parsing than hand-coded ones. Understand why for some applications we 
might be able to not care. Understand how to embed good error messages in a 
grammar-based approach vs. hand-coded solution. 
Understand the notion of unparsers, which, IIRC, are not covered in any of the 
Dragon Book at all.
```
